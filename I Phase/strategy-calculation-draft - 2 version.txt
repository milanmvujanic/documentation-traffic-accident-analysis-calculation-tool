public class ExportToWord {
	public void exportToWord(Calculation calculation) {
		writeToWord("Vn", calculation.fetchExportValues());
	}

	private void writeToWord(String parameter, List<Double> exportValues) {
		//impmlementation
	}
}

public class ResultFactory {
	public ICalculation getResult(List<String> args) {
		
		// this variable will hold description of the parameter
		// to be calculated, composed of string values selected
		// while specifying the desired calculation
		// For example, if "Vn" is selected, and "Sod" is known value,
		// and type of collision is "FullFrontImpact",
		// the description parameter will have value "VnSodFullFrontImpact"
		StringBuilder paramDesc = new StringBuilder();

		// this list will hold numeric values for calculation
		List<Double> calcValues = new ArrayList<>();	

		setParamDescAndCalcValues(paramDesc, calcValues);	

		switch (paramDesc.toString()) {
			case "VnSodFullFrontImpact":
				return new Result(
					new VnSodFullFrontImpact(calcValues));
			case "VnSodPartialFrontImpact":
				return new Result(
					new VnSodPartialFrontImpact(calcValues));
			case "VnSsz":
				return new Result(
					new VnSszFrontImpact(calcValues));
		}
	}

	private void setParamDescAndCalcValues(StringBuilder paramDesc, List<Double> calcValues) {
		for (int i = 0; i < 3; i++) {
			try {
				// if no "NumberFormatException" is thrown
				// it means that that is a numeric value
				// and it should be stored in "calcValues" list
				Double value = Double.parseDouble(args.get(i));
				calcValues.add(value);
			} catch (NumberFormatException nfe) {
				// if "NumberFormatException" is thrown
				// it means that that is a string value
				// and it should be used for composing of 
				// the description
				paramDesc.append(args.get(i));
			}
		}
	}
} 

public Inteface ICalculationAndExport {
	Map<String,Double> calculate();
	List<Double> fetchExportValues();
}

public class Result implements ICalculation {

	private IVn ivn;

	public Result(IVn ivn) {
		this.ivn = ivn;
	}

	public Map<String,Double> calculate() {
		ivn.calculateVn();
	}

	public List<Double> fetchExportValues() {
		ivn.fetchExportValuesVn();
	}
}

public interface IVn {
	Map<String,Double> calculateVn();
	List<Double> fetchExportValuesVn();
}

public class VnSodFullFrontImpact implements IVn {
	private Double Sod;
	private Double ma;
	private Double mp;
	private List<String> exportValuesVn;

	public VnSodFullFrontImpact(List<Double> calcValues) {
		this.Sod = calcValues.get(0);
		this.ma = calcValues.get(1);
		this.mp = calcValues.get(2);
		this.exportValuesVn = calcValues;
	}

	@Override
	public Map<String,Double> calculateVn() {
		return calculateVnSodFullFrontImpact();
	}

	@Override
	public List<Double> fetchExportValuesVn() {
		return this.exportValuesVn;
	}
	
	private Map<String,Double> calculateVnSodFullFrontImpact() {
		double result = **dummy calculation** (getSod() + getMa() + getMp());
		Map<String,Double> results = new HashMap<>();
		results.put("min", result * 0.9);
		results.put("max", result * 1,1);
		return results;
	}

	*getters and setters*
}

public class VnSodPartialFrontImpact implements IVn {
	private Double Sod;
	private Double ma;
	private Double mp;
	private List<String> exportValuesVn;

	public VnSodPartialFrontImpact(List<Double> calcValues) {
		this.Sod = calcValues.get(0);
		this.ma = calcValues.get(1);
		this.mp = calcValues.get(2);
		this.exportValuesVn = calcValues;
	}

	@Override
	public Map<String,Double> calculateVn() {
		return calculateVnSodPartialFrontImpact();
	}

	@Override
	public List<Double> fetchExportValuesVn() {
		return this.exportValuesVn;
	}
	
	private Map<String,Double> calculateVnSodPartialFrontImpact() {
		double result = **dummy calculation** (getSod() - getMa() - getMp());
		Map<String,Double> results = new HashMap<>();
		results.put("min", result * 0.8);
		results.put("max", result * 1,2);
		return results;
	}

	*getters and setters*
}

public class VodSszFrontImpact implements IVn {
	private Double Ssz;
	private Double b;
	private List<String> exportValuesVn;

	public VodSszFrontImpact(List<Double> calcValues) {
		this.Ssz = calcValues.get(0);
		this.b = calcValues.get(1);
		this.exportValuesVn = calcValues;
	}
	
	@Override	
	public Map<String,Double> calculateVn() {
		double result = **dummy calculation** (this.Ssz * this.b);
		Map<String,Double> results = new HashMap<>();
		results.put("result", result);
		return results;
	}

	@Override
	public List<Double> fetchExportValuesVn() {
		return this.exportValuesVn;
	}
}

